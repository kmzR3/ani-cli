#!/bin/sh

version_number="4.10.3"

# UI

external_menu() {
    rofi "$1" -sort -dmenu -i -width 1500 -p "$2" "$3"
}

launcher() {
    [ "$use_external_menu" = "0" ] && [ -z "$1" ] && set -- "+m" "$2"
    [ "$use_external_menu" = "0" ] && fzf "$1" --reverse --cycle --prompt "$2"
    [ "$use_external_menu" = "1" ] && external_menu "$1" "$2" "$external_menu_args"
}

nth() {
    stdin=$(cat -)
    [ -z "$stdin" ] && return 1
    line_count="$(printf "%s\n" "$stdin" | wc -l | tr -d "[:space:]")"
    [ "$line_count" -eq 1 ] && printf "%s" "$stdin" | cut -f2,3 && return 0
    prompt="$1"
    multi_flag=""
    [ $# -ne 1 ] && shift && multi_flag="$1"
    line=$(printf "%s" "$stdin" | cut -f1,3 | tr '\t' ' ' | launcher "$multi_flag" "$prompt" | cut -d " " -f 1)
    line_start=$(printf "%s" "$line" | head -n1)
    line_end=$(printf "%s" "$line" | tail -n1)
    [ -n "$line" ] || exit 1
    if [ "$line_start" = "$line_end" ]; then
        printf "%s" "$stdin" | grep -E '^'"${line}"'($|[[:space:]])' | cut -f2,3 || exit 1
    else
        printf "%s" "$stdin" | sed -n '/^'"${line_start}"'$/,/^'"${line_end}$"'/p' || exit 1
    fi
}

die() {
    printf "\33[2K\r\033[1;31m%s\033[0m\n" "$*" >&2
    exit 1
}
# --- AniList Integration ---

# AniList Configuration
ANILIST_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ani-cli"
ANILIST_CONFIG_FILE="$ANILIST_CONFIG_DIR/anilist.conf"
ANILIST_TOKEN_FILE="$ANILIST_CONFIG_DIR/token"
# AniList Title Mapping for Auto-Tracking
ANILIST_MAPPINGS_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ani-cli"
ANILIST_MAPPINGS_FILE="$ANILIST_MAPPINGS_DIR/mappings.conf"
# Ensure the mappings directory exists
mkdir -p "$ANILIST_MAPPINGS_DIR" 2>/dev/null || true # Ignore errors, path might exist or be unwritable

# Ensure config directory exists
mkdir -p "$ANILIST_CONFIG_DIR" 2>/dev/null || die "Failed to create AniList config directory: $ANILIST_CONFIG_DIR"

# Function to get config value
anilist_get_config() {
    local key="$1"
    if [ -f "$ANILIST_CONFIG_FILE" ]; then
        grep "^${key}=" "$ANILIST_CONFIG_FILE" | cut -d'=' -f2
    fi
}

# Function to set config value
anilist_set_config() {
    local key="$1"
    local value="$2"

    # Create file if it doesn't exist
    touch "$ANILIST_CONFIG_FILE" || die "Cannot create AniList config file"

    # Remove existing key if it exists
    if grep -q "^${key}=" "$ANILIST_CONFIG_FILE" 2>/dev/null; then
        grep -v "^${key}=" "$ANILIST_CONFIG_FILE" > "${ANILIST_CONFIG_FILE}.tmp" && mv "${ANILIST_CONFIG_FILE}.tmp" "$ANILIST_CONFIG_FILE"
    fi

    echo "${key}=${value}" >> "$ANILIST_CONFIG_FILE"
}

# Function to get access token
anilist_get_token() {
    if [ -f "$ANILIST_TOKEN_FILE" ]; then
        cat "$ANILIST_TOKEN_FILE"
    fi
}

# Function to save access token
anilist_save_token() {
    local token="$1"
    echo "$token" > "$ANILIST_TOKEN_FILE"
}

# Function to check if jq is available
anilist_check_jq() {
    if ! command -v jq >/dev/null 2>&1; then
        die "jq is required for AniList features. Please install jq."
    fi
}

# Function to make a GraphQL request to AniList
# Usage: anilist_graphql_query "$query_string" ["$variables_json_string"]
# Function to make a GraphQL request to AniList
# Usage: anilist_graphql_query "$query_string" ["$variables_json_string"]
# Function to make a GraphQL request to AniList
# Usage: anilist_graphql_query "$query_string" ["$variables_json_string"]
# Function to make a GraphQL request to AniList
# Usage: anilist_graphql_query "$query_string" ["$variables_json_string"]
anilist_graphql_query() {
    local query="$1"
    local variables="$2" # Optional JSON string for variables (must be a valid JSON object string like '{"status":["CURRENT"]}')

    local token
    token=$(anilist_get_token)

    # Correctly build headers array
    local headers_args=()
    headers_args+=("-H" "Content-Type: application/json")
    headers_args+=("-H" "Accept: application/json")
    if [ -n "$token" ]; then
        headers_args+=("-H" "Authorization: Bearer $token")
    fi

    # --- REVISED FIX: Use jq to build the JSON payload if available ---
    local data
    if command -v jq >/dev/null 2>&1; then
        # Use jq to build the JSON payload correctly.
        # If variables is provided and not empty, include it.
        if [ -n "$variables" ]; then
            # shellcheck disable=SC2016
            data=$(jq -n --arg query "$query" --argjson variables "$variables" '{query: $query, variables: $variables}')
        else
            # shellcheck disable=SC2016
            data=$(jq -n --arg query "$query" '{query: $query}')
        fi
    else
        # Fallback if jq is not available - simpler escaping
        # This is less robust but might work for simple queries without special chars
        local escaped_query
        # Basic escaping for JSON: escape backslashes and quotes
        escaped_query=$(printf '%s' "$query" | sed 's/\\/\\\\/g; s/"/\\"/g')
        if [ -n "$variables" ]; then
            data="{\"query\":\"$escaped_query\",\"variables\":$variables}"
        else
            data="{\"query\":\"$escaped_query\"}"
        fi
    fi

    # Check if data construction was successful
    if [ $? -ne 0 ] || [ -z "$data" ]; then
        die "Failed to construct GraphQL request payload."
    fi

    # Debug: Uncomment one or both lines below for debugging
    # echo "DEBUG: Sending GraphQL request DATA: $data" >&2
    # echo "DEBUG: Headers args: ${headers_args[*]}" >&2

    local response
    # shellcheck disable=SC2155
    # Use --data-binary to prevent curl from doing any processing on the data
    response=$(curl -s -X POST \
        "${headers_args[@]}" \
        --data-binary "$data" \
        "https://graphql.anilist.co")

    # Debug: Uncomment to see the raw response
    # echo "DEBUG: Raw GraphQL response: $response" >&2

    # Check for network errors in curl response itself (exit code)
    # Note: A 4xx/5xx HTTP status code does *not* make curl exit with non-zero by default
    if [ $? -ne 0 ]; then
        die "Network error occurred while contacting AniList API (curl failed)."
    fi

    # Check for HTTP protocol level errors (e.g., 500, 400) by checking if response is JSON with an 'errors' field
    # We prioritize checking the content over the HTTP status code for GraphQL APIs
    if command -v jq >/dev/null 2>&1; then
        # If jq is available, parse the JSON to check for errors
        if echo "$response" | jq -e '.errors' >/dev/null 2>&1; then
            # Try to get a detailed error message from the first error
            local error_msg
            # Use // to provide a fallback if .message is null/missing
            error_msg=$(echo "$response" | jq -r '.errors[0].message // "Unknown AniList API error (jq found errors array)"' 2>/dev/null)
            # Final fallback if jq command itself failed or produced empty output
            if [ $? -ne 0 ] || [ -z "$error_msg" ] || [ "$error_msg" = "null" ]; then
                 error_msg="Unknown AniList API error (failed to parse error message with jq)"
            fi
            die "AniList API Error: $error_msg"
        fi
    else
        # If jq is not available, do a basic check for the presence of "errors" in the response text
        # This is less reliable but a reasonable fallback
        if echo "$response" | grep -q '"errors"'; then
             die "AniList API returned an error (jq recommended for detailed errors). Response snippet: $(echo "$response" | head -c 200)..."
        fi
    fi

    # If we get here, the request was successful (as far as we can tell without jq)
    echo "$response"
}
# Function to setup AniList integration
anilist_setup() {
    echo "=== AniList Setup ==="
    echo "1. Go to https://anilist.co/settings/developer"
    echo "2. Click 'Create New Client'"
    echo "3. Fill in:"
    echo "   - Name: ani-cli-tracker"
    echo "   - Redirect URL: https://anilist.co/api/v2/oauth/pin"
    echo ""

    printf "Enter your AniList Client ID: "
    read -r client_id
    if [ -z "$client_id" ]; then
        die "Client ID cannot be empty."
    fi

    printf "Enter your AniList Client Secret: "
    read -rs client_secret
    echo # Newline after hidden input
    if [ -z "$client_secret" ]; then
        die "Client Secret cannot be empty."
    fi

    anilist_set_config "client_id" "$client_id"
    anilist_set_config "client_secret" "$client_secret"

    echo "Configuration saved successfully to $ANILIST_CONFIG_FILE!"
    echo "Now run 'ani-cli anilist-auth' to authenticate."
    exit 0
}

# Function to authenticate with AniList
anilist_auth() {
    anilist_check_jq # Ensure jq is available

    local client_id
    client_id=$(anilist_get_config "client_id")
    local client_secret
    client_secret=$(anilist_get_config "client_secret")

    if [ -z "$client_id" ] || [ -z "$client_secret" ]; then
        die "AniList Client ID or Secret not configured. Run 'ani-cli anilist-setup' first."
    fi

    local auth_url="https://anilist.co/api/v2/oauth/authorize?client_id=${client_id}&response_type=code"
    echo "Please visit this URL to authenticate:"
    echo "$auth_url"
    echo ""
    printf "Press Enter after visiting the URL to continue..."
    read -r

    printf "Enter the authorization code from the URL: "
    read -r auth_code

    if [ -z "$auth_code" ]; then
        die "Authorization code cannot be empty."
    fi

    # Exchange code for token
    echo "Exchanging code for access token..."
    local response
    response=$(curl -s -X POST \
        -d "grant_type=authorization_code" \
        -d "client_id=$client_id" \
        -d "client_secret=$client_secret" \
        -d "redirect_uri=https://anilist.co/api/v2/oauth/pin" \
        -d "code=$auth_code" \
        "https://anilist.co/api/v2/oauth/token")

    # Debug: Uncomment to see raw auth response
    # echo "DEBUG: Raw auth response: $response" >&2

    # Check for curl errors
    if [ $? -ne 0 ]; then
        die "Network error occurred during authentication"
    fi

    # Parse response using jq
    local access_token
    access_token=$(echo "$response" | jq -r '.access_token' 2>/dev/null)

    if [ "$access_token" = "null" ] || [ -z "$access_token" ] || [ "$access_token" = "" ]; then
        local error_description
        error_description=$(echo "$response" | jq -r '.error_description // .error // "Unknown error"' 2>/dev/null)
        die "Authentication failed: $error_description"
    fi

    anilist_save_token "$access_token"
    echo "Authentication successful! Token saved."
    exit 0
}

# Function to search anime on AniList
anilist_search() {
    anilist_check_jq

    local search_term="$1"

    if [ -z "$search_term" ]; then
        die "Usage: ani-cli anilist-search <search_term>"
    fi

    echo "Searching AniList for: $search_term"

    # GraphQL query must be on one line for shell escaping
    local query="query (\$search: String) { Page { media (search: \$search, type: ANIME) { id title { romaji english } episodes status } } }"
    local variables="{\"search\":\"${search_term}\"}"

    local response
    response=$(anilist_graphql_query "$query" "$variables")

    # Check if response is valid JSON and has data
    if ! echo "$response" | jq -e '.data.Page.media' >/dev/null 2>&1; then
        echo "No results found or error parsing response."
        exit 1
    fi

    # Check if results exist
    local result_count
    result_count=$(echo "$response" | jq '.data.Page.media | length')

    if [ "$result_count" -eq 0 ]; then
        echo "No anime found matching '$search_term'."
        exit 0
    fi

    echo "Found $result_count result(s):"
    echo "$response" | jq -r '.data.Page.media[] | "[\(.id)] \(.title.romaji) (\(.title.english // "N/A")) - Episodes: \(.episodes // "?") Status: \(.status // "Unknown")"'
    exit 0
}

# Function to update progress
anilist_update_progress() {
    anilist_check_jq

    local media_id="$1"
    local progress="$2"
    local status="${3:-CURRENT}" # Default to CURRENT if not provided

    if [ -z "$media_id" ] || [ -z "$progress" ]; then
        die "Usage: ani-cli anilist-update <media_id> <progress> [status]"
    fi

    # Validate media_id is a number
    if ! printf "%d" "$media_id" >/dev/null 2>&1; then
        die "Media ID must be a number."
    fi

    # Validate progress is a number
    if ! printf "%d" "$progress" >/dev/null 2>&1; then
        die "Progress must be a number."
    fi

    # Validate status is one of the allowed values (basic check)
    case "$status" in
        CURRENT|PLANNING|COMPLETED|DROPPED|PAUSED|REPEATING) ;;
        *) echo "Warning: '$status' might not be a standard AniList status." ;;
    esac

    echo "Updating progress for Media ID $media_id to episode $progress (Status: $status)..."

    # GraphQL mutation must be on one line
    local mutation="mutation (\$mediaId: Int, \$status: MediaListStatus, \$progress: Int) { SaveMediaListEntry (mediaId: \$mediaId, status: \$status, progress: \$progress) { id status progress } }"
    local variables="{\"mediaId\":$media_id,\"status\":\"$status\",\"progress\":$progress}"

    local response
    response=$(anilist_graphql_query "$mutation" "$variables")

    # The function anilist_graphql_query already handles errors, so if we get here, it likely succeeded.
    echo "Progress updated successfully!"
    exit 0
}

# Function to get user's anime list
# Function to get user's anime list
anilist_get_list() {
    anilist_check_jq # Ensure jq is available for parsing

    echo "Fetching your AniList anime list..."

    # Check authentication first
    local token
    token=$(anilist_get_token)
    if [ -z "$token" ]; then
        die "Not authenticated with AniList. Run 'ani-cli anilist-auth' first."
    fi

    # --- First, get the Viewer's ID ---
    local viewer_query="query { Viewer { id name } }"
    local viewer_response
    viewer_response=$(anilist_graphql_query "$viewer_query")

    # Debug: Uncomment to see viewer response
    # echo "DEBUG: Viewer response: $viewer_response" >&2

    # Extract user ID and name using jq
    local user_id
    user_id=$(echo "$viewer_response" | jq -r '.data.Viewer.id // empty')
    local username
    username=$(echo "$viewer_response" | jq -r '.data.Viewer.name // "Unknown User"')

    if [ -z "$user_id" ] || [ "$user_id" = "null" ]; then
        die "Failed to get AniList user ID. Response: $viewer_response"
    fi

    echo "User: $username (ID: $user_id)"

    # --- Now, get the MediaListCollection using the user ID ---
    # Use the query structure from the Go code (internal.go line 478)
    local list_query="query (\$userId: Int, \$status: [MediaListStatus]) {
      MediaListCollection(userId: \$userId, type: ANIME, status_in: \$status) {
        lists {
          name
          isCustomList
          isSplitCompletedList
          status
          entries {
            id
            progress
            status
            score
            media {
              id
              title {
                romaji
                english
              }
              episodes
              duration
            }
          }
        }
      }
    }"

    # Define the variables for the query (matching Go code line 497-ish)
    # Using the statuses found in the Go code logic (internal.go line 715+)
    local list_variables="{\"userId\":$user_id,\"status\":[\"CURRENT\",\"PLANNING\",\"COMPLETED\",\"DROPPED\",\"PAUSED\",\"REPEATING\"]}"

    local list_response
    list_response=$(anilist_graphql_query "$list_query" "$list_variables")

    # Debug: Uncomment to see list response
    # echo "DEBUG: List response: $list_response" >&2

    # Check if the response contains the expected data structure
    if ! echo "$list_response" | jq -e '.data.MediaListCollection' >/dev/null 2>&1; then
        echo "No anime lists found or error retrieving lists."
        # Show a snippet of the response for debugging if it looks like an error
        if echo "$list_response" | grep -q '"errors"'; then
            echo "Response snippet: $(echo "$list_response" | head -c 300)..."
        fi
        exit 1
    fi

    # Check if any lists were returned
    local list_count
    list_count=$(echo "$list_response" | jq '.data.MediaListCollection.lists | length')

    if [ "$list_count" -eq 0 ] || [ "$list_count" = "null" ]; then
        echo "You have no anime in tracked lists (Current, Planning, Completed, etc.)."
        exit 0
    fi

    echo "Found $list_count list(s):"

    # Iterate through the lists returned by the API
    local i
    for i in $(seq 0 $((list_count - 1))); do
        local list_name
        local list_status
        local list_entries_json

        list_name=$(echo "$list_response" | jq -r ".data.MediaListCollection.lists[$i].name // empty")
        list_status=$(echo "$list_response" | jq -r ".data.MediaListCollection.lists[$i].status // empty")
        # Get the raw JSON array for entries in this list
        list_entries_json=$(echo "$list_response" | jq ".data.MediaListCollection.lists[$i].entries")

        # Determine the display name for the list
        local display_name
        if [ -n "$list_name" ] && [ "$list_name" != "null" ]; then
            display_name="$list_name"
        elif [ -n "$list_status" ] && [ "$list_status" != "null" ]; then
            display_name="$list_status"
        else
            display_name="List $((i+1))"
        fi

        # Count entries in this specific list
        local entry_count
        entry_count=$(echo "$list_entries_json" | jq 'length')

        if [ "$entry_count" -gt 0 ]; then
            echo ""
            echo "$display_name ($entry_count):"
            # Iterate through entries and print them
            echo "$list_entries_json" | jq -r '.[] | "  - \(.media.title.english // .media.title.romaji // "Unknown Title") (EP \(.progress // 0)/\(.media.episodes // "?")) [\(.status // "UNKNOWN")]"'
        fi
    done

    exit 0
}

# Function for automatic tracking after episode play
# Enhanced version with interactive fallback for ID mapping
anilist_auto_track() {
    # Receive title and episode number from play_episode
    local anime_title="$1"
    local episode_number="$2"

    # Basic validation
    if [ -z "$anime_title" ] || [ -z "$episode_number" ]; then
        return 0 # Silently exit if missing info
    fi

    # --- Step 1: Try to get the AniList Media ID ---

    # Priority 1: Use the pre-determined AniList Media ID (e.g., from anilist-select)
    local anime_id="$ANILIST_SELECTED_MEDIA_ID"

    # Priority 2: Check if we have a saved mapping for this scraped title
    if [ -z "$anime_id" ] || [ "$anime_id" = "null" ]; then
        anime_id=$(anilist_get_mapped_id "$anime_title")
        if [ -n "$anime_id" ] && [ "$anime_id" != "null" ]; then
             echo "Found AniList ID $anime_id for '$anime_title' in mappings." >&2 # Optional debug
        fi
    fi

    # --- Step 2: If no ID found, ask the user ---
    if [ -z "$anime_id" ] || [ "$anime_id" = "null" ]; then
        echo "AniList tracking: Could not automatically find ID for '$anime_title'."
        printf "Please enter the correct anime name as it appears on AniList (or press Enter to skip): "
        local user_provided_name
        read -r user_provided_name

        if [ -n "$user_provided_name" ]; then
            # --- Step 3: Search AniList using the user's provided name ---
            # Check Authentication
            local token
            token=$(anilist_get_token)
            if [ -z "$token" ]; then
                echo "AniList tracking: Not authenticated. Cannot search for '$user_provided_name'."
                return 0
            fi

            # Perform the search
            local search_query='query ($search: String) {
                Page(perPage: 5) {
                    media(search: $search, type: ANIME, sort: SEARCH_MATCH) {
                        id
                        title { romaji english }
                    }
                }
            }'
            # Properly escape the search term for JSON
            local search_variables
            search_variables=$(printf '{"search":"%s"}' "$user_provided_name")

            local search_response
            search_response=$(anilist_graphql_query "$search_query" "$search_variables")

            # Extract the ID from the first result (assume user chose correctly)
            anime_id=$(echo "$search_response" | jq -r '.data.Page.media[0].id // empty' 2>/dev/null)

            if [ -n "$anime_id" ] && [ "$anime_id" != "null" ]; then
                # --- Step 4: Save the mapping ---
                anilist_save_mapping "$anime_title" "$anime_id"
                echo "AniList tracking: Mapped '$anime_title' to '$user_provided_name' (ID: $anime_id). Will auto-track this anime in the future."
            else
                echo "AniList tracking: Could not find an anime named '$user_provided_name' on AniList. Skipping tracking for '$anime_title'."
                return 0
            fi
        else
            # User pressed Enter, skip tracking
            echo "AniList tracking: Skipped for '$anime_title'."
            return 0
        fi
    fi

    # --- Step 5: Validate Episode Number ---
    local clean_episode_number
    clean_episode_number=$(printf "%d" "$episode_number" 2>/dev/null)
    if [ $? -ne 0 ]; then
        # Not a valid integer
        echo "AniList tracking: Episode number '$episode_number' is invalid. Skipping update for '$anime_title'." >&2
        return 0
    fi

    # --- Step 6: Validate Authentication (if we got this far without a pre-set ID) ---
    # If ANILIST_SELECTED_MEDIA_ID was set, token was likely already checked.
    # But if ID came from mapping or user input, double-check.
    if [ -z "$ANILIST_SELECTED_MEDIA_ID" ]; then # Only check if ID wasn't from anilist-select
        local token
        token=$(anilist_get_token)
        if [ -z "$token" ]; then
            echo "AniList tracking: Not authenticated. Cannot update progress for '$anime_title'." >&2
            return 0
        fi
    fi

    # --- Step 7: Update Progress on AniList ---
    # Prepare the GraphQL mutation
    local update_mutation='mutation ($mediaId: Int, $progress: Int) {
        SaveMediaListEntry(mediaId: $mediaId, progress: $progress) {
            id
            progress
        }
    }'
    # Properly format the JSON variables
    local update_variables
    update_variables=$(printf '{"mediaId":%s,"progress":%s}' "$anime_id" "$clean_episode_number")

    # Make the API call using the existing helper
    # Run in background to avoid blocking script exit, redirect output
    anilist_graphql_query "$update_mutation" "$update_variables" >/dev/null 2>&1 &

    # Optional: Print a confirmation message to the terminal
    echo "AniList progress update requested for '$anime_title' (ID: $anime_id) to episode $clean_episode_number."

    # Note: Because it runs in the background (&), we don't wait for the result here.
    # The script can exit, and the update should still complete.
}
# Function to format AniList data for the selector (fzf/rofi)
# Similar logic to anilist_get_list but prepares a string for nth instead of printing
# Function to save a scraped title to AniList ID mapping
# Usage: anilist_save_mapping "Scraped Anime Title" "12345"
anilist_save_mapping() {
    local scraped_title="$1"
    local anilist_id="$2"

    if [ -z "$scraped_title" ] || [ -z "$anilist_id" ]; then
        return 1 # Invalid input
    fi

    # Ensure the mappings file exists
    touch "$ANILIST_MAPPINGS_FILE" 2>/dev/null || return 1

    # Escape potential special characters in the title for sed
    # This prevents issues if the title contains '/', '&', or the delimiter '|'
    local escaped_title
    escaped_title=$(printf '%s\n' "$scraped_title" | sed 's/[^^]/[&]/g; s/\^/\\^/g')

    # Check if the mapping already exists
    if grep -q "^${escaped_title}|" "$ANILIST_MAPPINGS_FILE" 2>/dev/null; then
        # Mapping exists, update the ID
        # Use a different delimiter (#) for sed to avoid conflicts with '/' in IDs/paths
        sed -i.bak "s#^${escaped_title}|.*#${scraped_title}|${anilist_id}#" "$ANILIST_MAPPINGS_FILE" 2>/dev/null
        # Remove the backup file created by sed -i.bak
        rm -f "${ANILIST_MAPPINGS_FILE}.bak"
    else
        # Mapping doesn't exist, append it
        echo "${scraped_title}|${anilist_id}" >> "$ANILIST_MAPPINGS_FILE"
    fi
}
# Function to get the AniList ID for a scraped title from the mapping file
# Usage: anilist_get_mapped_id "Scraped Anime Title"
# Returns the ID via echo, or nothing if not found
anilist_get_mapped_id() {
    local scraped_title="$1"

    if [ -z "$scraped_title" ] || [ ! -f "$ANILIST_MAPPINGS_FILE" ]; then
        return 1 # No title provided or mappings file doesn't exist
    fi

    # Escape potential special characters in the title for grep
    local escaped_title
    escaped_title=$(printf '%s\n' "$scraped_title" | sed 's/[[\.*^$()+?{|]/\\&/g')

    # Search for the line starting with the exact title followed by '|'
    # Extract the ID part (after the '|')
    grep "^${escaped_title}|" "$ANILIST_MAPPINGS_FILE" 2>/dev/null | cut -d'|' -f2 | head -n 1
}
anilist_format_for_selector() {
    # This function echoes the formatted string for nth
    # Check authentication first
    local token
    token=$(anilist_get_token)
    if [ -z "$token" ]; then
       # Return error code instead of dying, let caller handle it
       return 1
    fi

    # --- Get User ID ---
    local viewer_query="query { Viewer { id name } }"
    local viewer_response
    viewer_response=$(anilist_graphql_query "$viewer_query")
    local user_id
    user_id=$(echo "$viewer_response" | jq -r '.data.Viewer.id // empty')
    if [ -z "$user_id" ] || [ "$user_id" = "null" ]; then
        return 1
    fi

    # --- Get MediaListCollection in the desired order ---
    # Fetch lists for CURRENT, REPEATING, PLANNING, COMPLETED, DROPPED, PAUSED
    # This order determines the display order in the selector
    local list_query="query (\$userId: Int, \$status: [MediaListStatus]) {
      MediaListCollection(userId: \$userId, type: ANIME, status_in: \$status) {
        lists {
          name
          status
          entries {
            id
            progress
            status
            media {
              id
              title {
                romaji
                english
              }
              episodes
            }
          }
        }
      }
    }"
    # Define the status order for fetching AND displaying
    # The order in this array determines the order categories appear in the selector
    local list_variables="{\"userId\":$user_id,\"status\":[\"CURRENT\",\"REPEATING\",\"PLANNING\",\"COMPLETED\",\"DROPPED\",\"PAUSED\"]}"

    local list_response
    list_response=$(anilist_graphql_query "$list_query" "$list_variables")

    # Check if the response contains the expected data structure
    if ! echo "$list_response" | jq -e '.data.MediaListCollection' >/dev/null 2>&1; then
        return 1
    fi

    # --- Build the string for the selector ---
    local grouped_entries_str=""
    # Define the order and display names for statuses
    # Format: "API_STATUS_KEY:DISPLAY_NAME"
    local status_display_order=(
        "CURRENT:Watching"
        "REPEATING:Rewatching"
        "PLANNING:Planning"
        "COMPLETED:Completed"
        "DROPPED:Dropped"
        "PAUSED:Paused"
    )

    # Iterate through the defined display order
    local status_entry
    local status_key
    local display_name
    local list_json
    local entry_count
    local formatted_entries
    for status_entry in "${status_display_order[@]}"; do
        # Split the status_entry into status_key and display_name
        IFS=':' read -r status_key display_name <<< "$status_entry"

        # Use jq to extract the list data for this specific status
        list_json=$(echo "$list_response" | jq -e --arg status_key "$status_key" '.data.MediaListCollection.lists[] | select(.status == $status_key)' 2>/dev/null)

        # Check if jq found a list for this status
        if [ $? -eq 0 ] && [ -n "$list_json" ]; then
            # Get the number of entries in this list
            entry_count=$(echo "$list_json" | jq -r '.entries | length')

            # Only add the category if it has entries
            if [ "$entry_count" -gt 0 ]; then
                # Add the category header (no tab, not selectable by nth)
                grouped_entries_str="${grouped_entries_str}${display_name} (${entry_count})"$'\n'

                # Use jq to format the entries for this list
                # Format for nth: "  MediaID\tTitle (Episodes) - Progress: X/Y"
                # The leading '  ' (two spaces) is crucial for visual distinction in fzf/rofi
                # and to help distinguish from headers (though nth itself doesn't care about this)
                formatted_entries=$(echo "$list_json" | jq -r '.entries[] |
                    .media.id as $id |
                    (.media.title.english // .media.title.romaji // "Unknown Title") as $title |
                    (.media.episodes // "?") as $episodes |
                    "  \($id)\t\($title) (\($episodes) episodes) - Progress: \(.progress)/\($episodes)"
                ' 2>/dev/null)

                # Check if jq formatting was successful
                if [ $? -eq 0 ]; then
                    # Append the formatted entries to the main string
                    grouped_entries_str="${grouped_entries_str}${formatted_entries}"$'\n'
                     # Add a blank line for visual separation between categories in fzf/rofi
                     grouped_entries_str="${grouped_entries_str}"$'\n'
                else
                    # If jq failed on this list's entries, add a placeholder
                    grouped_entries_str="${grouped_entries_str}  (Error formatting entries for this list)"$'\n'
                fi
            fi
        fi
        # If jq didn't find the status, the user has no entries in that list.
        # We simply don't add a header for it.
    done

    # Echo the final formatted string so the caller can capture it
    printf "%s" "$grouped_entries_str"
    return 0
}
# Function to handle the anilist-select command logic
# Fetches 'Watching' list, determines next episode,
# and executes a new 'ani-cli -e <ep> <title>' command.
select_from_anilist() {
    # --- AniList Selection Mode ---
    anilist_check_jq

    token=$(anilist_get_token)
    if [ -z "$token" ]; then
        die "Not authenticated with AniList. Run 'ani-cli anilist-auth' first."
    fi

    echo "Fetching your 'Watching' list from AniList..."

    # --- Get User ID ---
    viewer_query="query { Viewer { id name } }"
    viewer_response=$(anilist_graphql_query "$viewer_query")
    user_id=$(echo "$viewer_response" | jq -r '.data.Viewer.id // empty')
    username=$(echo "$viewer_response" | jq -r '.data.Viewer.name // "Unknown User"')
    if [ -z "$user_id" ] || [ "$user_id" = "null" ]; then
        die "Failed to get AniList user ID."
    fi
    echo "User: $username"

    # --- Get ONLY the CURRENT (Watching) list ---
    list_query="query (\$userId: Int) {
      MediaListCollection(userId: \$userId, type: ANIME, status: CURRENT) {
        lists {
          entries {
            id
            progress
            media {
              id
              title {
                romaji
                english
              }
              episodes
            }
          }
        }
      }
    }"
    list_variables="{\"userId\":$user_id}"

    list_response=$(anilist_graphql_query "$list_query" "$list_variables")

    # Check if the response contains the expected data structure and has a list
    if ! echo "$list_response" | jq -e '.data.MediaListCollection.lists[0]' >/dev/null 2>&1; then
        die "No 'Watching' list found or error retrieving it from AniList."
    fi

    # --- Extract and Format Entries for nth (DisplayTitle\tID) ---
    # Format for nth: "Title (EP Progress/Total)\tMediaID"
    formatted_entries=$(echo "$list_response" | jq -r '
        .data.MediaListCollection.lists[0].entries[] |
        .media.id as $media_id |
        (.media.title.english // .media.title.romaji // "Unknown Title") as $title |
        (.media.episodes // "?") as $total_episodes |
        .progress as $progress |
        "\($title) (EP \($progress)/\($total_episodes))\t\($media_id)"
    ' 2>/dev/null)

    # Check if any entries were found
    if [ $? -ne 0 ] || [ -z "$formatted_entries" ]; then
         die "Failed to process your 'Watching' list data or it is empty."
    fi

    # --- Let User Select an Anime ---
    echo "Select an anime from your 'Watching' list:"
    result=""
    result=$(printf "%s" "$formatted_entries" | nth "Select anime: ")

    # Check if a selection was made
    if [ -z "$result" ]; then
        echo "No anime selected. Exiting."
        exit 1
    fi
    # At this point, `result` holds the full selected line: "Title (EP Progress/Total)\tActualMediaID"

    # --- Extract Data from Selection ---
    # Extract the display part (FIRST field before tab) - This is what the user saw/selected
    display_part=$(printf "%s" "$result" | cut -f1)
    # Extract the Actual AniList Media ID (second field after tab) - For potential future use/tracking
    # anilist_media_id=$(printf "%s" "$result" | cut -f2) # Not used in this approach

    # --- Extract Clean Title for the New Command ---
    # Get "Title" from "Title (EP Progress/TotalEpisodes)"
    title_for_command=$(printf "%s" "$display_part" | awk -F' \\(EP' '{print $1}')
    if [ -z "$title_for_command" ]; then
        title_for_command=$(printf "%s" "$display_part" | sed 's/ (.*)$//')
    fi
    if [ -z "$title_for_command" ]; then
        title_for_command="$display_part"
    fi

    # --- Determine Episode Number to Play ---
    # Extract progress from the display_part "Title (EP Progress/Total)"
    current_progress=""
    current_progress=$(printf "%s" "$display_part" | sed -n 's/.*(EP \([0-9]*\)\/.*/\1/p')

    ep_no="" # Initialize the episode number variable
    if [ -n "$current_progress" ] && [ "$current_progress" -ge 0 ] 2>/dev/null; then
        # Calculate the next episode number to play
        ep_no=$((current_progress + 1))
        echo "Determined next episode based on AniList progress ($current_progress): $ep_no"
    else
        # If progress couldn't be determined, we cannot proceed automatically.
        echo "Could not determine progress from AniList entry '$display_part'. Cannot continue automatically."
        exit 1
    fi

    # --- Construct and Execute the New ani-cli Command ---
    # Use the script's own name ($0) to ensure we call the correct instance
    # Quote the title to handle spaces and special characters
    new_command="$0 -e $ep_no \"$title_for_command\""

    echo "Executing: $new_command"
    # Execute the new command. Using 'exec' replaces the current process.
    # If you want the original ani-cli to continue running after (e.g., for tracking),
    # remove 'exec' and just run the command.
    exec $new_command

    # Note: If exec is used, the lines below will not be reached.
    # If you remove exec, you might want logic here to handle post-playback
    # actions like AniList tracking if desired, although the new instance
    # of ani-cli should handle its own tracking if auto-tracking is enabled.
}

help_info() {
    printf "
    Usage:
    %s [options] [query]
    %s [query] [options]
    %s [options] [query] [options]

    Options:
      -c, --continue
        Continue watching from history
      -d, --download
        Download the video instead of playing it
      -D, --delete
        Delete history
      -l, --logview
        Show logs
      -s, --syncplay
        Use Syncplay to watch with friends
      -S, --select-nth
        Select nth entry
      -q, --quality
        Specify the video quality
      -v, --vlc
        Use VLC to play the video
      -V, --version
        Show the version of the script
      -h, --help
        Show this help message and exit
      -e, --episode, -r, --range
        Specify the number of episodes to watch
      --dub
        Play dubbed version
      --rofi
        Use rofi instead of fzf for the interactive menu
      --skip
        Use ani-skip to skip the intro of the episode (mpv only)
      --no-detach
        Don't detach the player (useful for in-terminal playback, mpv only)
      --exit-after-play
        Exit the player, and return the player exit code (useful for non interactive scenarios, mpv only)
      --skip-title <title>
        Use given title as ani-skip query
      -N, --nextep-countdown
        Display a countdown to the next episode
      -U, --update
        Update the script
    AniList Commands:
        anilist-setup           Setup AniList integration (first time only)
        anilist-auth            Authenticate with AniList
        anilist-search <term>   Search for anime on AniList
        anilist-update <id> <ep> Update episode progress
        anilist-list            Show your anime list
        anilist-select          Select anime from anilist to watch
    Some example usages:
      %s -q 720p banana fish
      %s --skip --skip-title \"one piece\" -S 2 one piece
      %s -d -e 2 cyberpunk edgerunners
      %s --vlc cyberpunk edgerunners -q 1080p -e 4
      %s blue lock -e 5-6
      %s -e \"5 6\" blue lock
    \n" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}" "${0##*/}"
    exit 0
}

version_info() {
    printf "%s\n" "$version_number"
    exit 0
}

update_script() {
    update="$(curl -s -A "$agent" "https://raw.githubusercontent.com/pystardust/ani-cli/master/ani-cli")" || die "Connection error"
    update="$(printf '%s\n' "$update" | diff -u "$0" -)"
    if [ -z "$update" ]; then
        printf "Script is up to date :)\n"
    else
        if printf '%s\n' "$update" | patch "$0" -; then
            printf "Script has been updated\n"
        else
            die "Can't update for some reason!"
        fi
    fi
    exit 0
}

# checks if dependencies are present
dep_ch() {
    for dep; do
        command -v "${dep%% *}" >/dev/null || die "Program \"${dep%% *}\" not found. Please install it."
    done
}

where_iina() {
    [ -e "/Applications/IINA.app/Contents/MacOS/iina-cli" ] && echo "/Applications/IINA.app/Contents/MacOS/iina-cli" && return 0
    printf "%s" "iina" && return 0
}

where_mpv() {
    command -v "flatpak" >/dev/null && flatpak info io.mpv.Mpv >/dev/null 2>&1 && printf "%s" "flatpak_mpv" && return 0
    printf "%s" "mpv" && return 0
}

# SCRAPING

# extract the video links from response of embed urls, extract mp4 links form m3u8 lists
get_links() {
    response="$(curl -e "$allanime_refr" -s "https://${allanime_base}$*" -A "$agent")"
    episode_link="$(printf '%s' "$response" | sed 's|},{|\
|g' | sed -nE 's|.*link":"([^"]*)".*"resolutionStr":"([^"]*)".*|\2 >\1|p;s|.*hls","url":"([^"]*)".*"hardsub_lang":"en-US".*|\1|p')"

    case "$episode_link" in
        *repackager.wixmp.com*)
            extract_link=$(printf "%s" "$episode_link" | cut -d'>' -f2 | sed 's|repackager.wixmp.com/||g;s|\.urlset.*||g')
            for j in $(printf "%s" "$episode_link" | sed -nE 's|.*/,([^/]*),/mp4.*|\1|p' | sed 's|,|\
|g'); do
                printf "%s >%s\n" "$j" "$extract_link" | sed "s|,[^/]*|${j}|g"
            done | sort -nr
            ;;
        *master.m3u8*)
            m3u8_refr=$(printf '%s' "$response" | sed -nE 's|.*Referer":"([^"]*)".*|\1|p') && printf '%s\n' "m3u8_refr >$m3u8_refr" >"$cache_dir/m3u8_refr"
            extract_link=$(printf "%s" "$episode_link" | head -1 | cut -d'>' -f2)
            relative_link=$(printf "%s" "$extract_link" | sed 's|[^/]*$||')
            m3u8_streams="$(curl -e "$m3u8_refr" -s "$extract_link" -A "$agent")"
            printf "%s" "$m3u8_streams" | grep -q "EXTM3U" && printf "%s" "$m3u8_streams" | sed 's|^#EXT-X-STREAM.*x||g; s|,.*|p|g; /^#/d; $!N; s|\n| >|;/EXT-X-I-FRAME/d' |
                sed "s|>|cc>${relative_link}|g" | sort -nr
            printf '%s' "$response" | sed -nE 's|.*"subtitles":\[\{"lang":"en","label":"English","default":"default","src":"([^"]*)".*|subtitle >\1|p' >"$cache_dir/suburl"
            ;;
        *) [ -n "$episode_link" ] && printf "%s\n" "$episode_link" ;;
    esac

    printf "%s" "$*" | grep -q "tools.fast4speed.rsvp" && printf "%s\n" "Yt >$*"
    printf "\033[1;32m%s\033[0m Links Fetched\n" "$provider_name" 1>&2
}

# initialises provider_name and provider_id. First argument is the provider name, 2nd is the regex that matches that provider's link
provider_init() {
    provider_name=$1
    provider_id=$(printf "%s" "$resp" | sed -n "$2" | head -1 | cut -d':' -f2 | sed 's/../&\
/g' | sed 's/^79$/A/g;s/^7a$/B/g;s/^7b$/C/g;s/^7c$/D/g;s/^7d$/E/g;s/^7e$/F/g;s/^7f$/G/g;s/^70$/H/g;s/^71$/I/g;s/^72$/J/g;s/^73$/K/g;s/^74$/L/g;s/^75$/M/g;s/^76$/N/g;s/^77$/O/g;s/^68$/P/g;s/^69$/Q/g;s/^6a$/R/g;s/^6b$/S/g;s/^6c$/T/g;s/^6d$/U/g;s/^6e$/V/g;s/^6f$/W/g;s/^60$/X/g;s/^61$/Y/g;s/^62$/Z/g;s/^59$/a/g;s/^5a$/b/g;s/^5b$/c/g;s/^5c$/d/g;s/^5d$/e/g;s/^5e$/f/g;s/^5f$/g/g;s/^50$/h/g;s/^51$/i/g;s/^52$/j/g;s/^53$/k/g;s/^54$/l/g;s/^55$/m/g;s/^56$/n/g;s/^57$/o/g;s/^48$/p/g;s/^49$/q/g;s/^4a$/r/g;s/^4b$/s/g;s/^4c$/t/g;s/^4d$/u/g;s/^4e$/v/g;s/^4f$/w/g;s/^40$/x/g;s/^41$/y/g;s/^42$/z/g;s/^08$/0/g;s/^09$/1/g;s/^0a$/2/g;s/^0b$/3/g;s/^0c$/4/g;s/^0d$/5/g;s/^0e$/6/g;s/^0f$/7/g;s/^00$/8/g;s/^01$/9/g;s/^15$/-/g;s/^16$/./g;s/^67$/_/g;s/^46$/~/g;s/^02$/:/g;s/^17$/\//g;s/^07$/?/g;s/^1b$/#/g;s/^63$/\[/g;s/^65$/\]/g;s/^78$/@/g;s/^19$/!/g;s/^1c$/$/g;s/^1e$/&/g;s/^10$/\(/g;s/^11$/\)/g;s/^12$/*/g;s/^13$/+/g;s/^14$/,/g;s/^03$/;/g;s/^05$/=/g;s/^1d$/%/g' | tr -d '\n' | sed "s/\/clock/\/clock\.json/")
}

# generates links based on given provider
generate_link() {
    case $1 in
        1) provider_init "wixmp" "/Default :/p" ;;    # wixmp(default)(m3u8)(multi) -> (mp4)(multi)
        2) provider_init "youtube" "/Yt-mp4 :/p" ;;   # youtube(mp4)(single)
        3) provider_init "sharepoint" "/S-mp4 :/p" ;; # sharepoint(mp4)(single)
        *) provider_init "hianime" "/Luf-Mp4 :/p" ;;  # hianime(m3u8)(multi)
    esac
    [ -n "$provider_id" ] && get_links "$provider_id"
}

select_quality() {
    # removing urls which have soft subs to avoid playing on android, iSH and vlc (m3u8 streams don't get correct referrer)
    printf '%s' "$player_function" | cut -f1 -d" " | grep -qE '(android|iSH|vlc)' && links=$(printf '%s' "$links" | sed '/cc>/d;/subtitle >/d;/m3u8_refr >/d')
    printf '%s' "$player_function" | cut -f1 -d" " | grep -qE '(android|iSH)' && links=$(printf '%s' "$links" | sed '/Yt >/d')
    case "$1" in
        best) result=$(printf "%s" "$links" | head -n1) ;;
        worst) result=$(printf "%s" "$links" | grep -E '^[0-9]{3,4}' | tail -n1) ;;
        *) result=$(printf "%s" "$links" | grep -m 1 "$1") ;;
    esac
    [ -z "$result" ] && printf "Specified quality not found, defaulting to best\n" 1>&2 && result=$(printf "%s" "$links" | head -n1)

    # add refr,sub flags for m3u8 and refr flag for yt
    printf '%s' "$result" | grep -q "cc>" && subtitle="$(printf '%s' "$links" | sed -nE 's|subtitle >(.*)|\1|p')" &&
        [ -n "$subtitle" ] && subs_flag="--sub-file=$subtitle"
    printf '%s' "$result" | grep -q "cc>" && m3u8_refr="$(printf '%s' "$links" | sed -nE 's|m3u8_refr >(.*)|\1|p')" && refr_flag="--referrer=$m3u8_refr"
    printf "%s" "$result" | grep -q "tools.fast4speed.rsvp" && refr_flag="--referrer=$allanime_refr"

    ! (printf '%s' "$result" | grep -qE "(cc>|tools.fast4speed.rsvp)") && unset refr_flag
    ! (printf '%s' "$result" | grep -q "cc>") && unset subs_flag
    episode=$(printf "%s" "$result" | cut -d'>' -f2)
}

# gets embed urls, collects direct links into provider files, selects one with desired quality into $episode
get_episode_url() {
    # get the embed urls of the selected episode
    #shellcheck disable=SC2016
    episode_embed_gql='query ($showId: String!, $translationType: VaildTranslationTypeEnumType!, $episodeString: String!) { episode( showId: $showId translationType: $translationType episodeString: $episodeString ) { episodeString sourceUrls }}'

    resp=$(curl -e "$allanime_refr" -s -G "${allanime_api}/api" --data-urlencode "variables={\"showId\":\"$id\",\"translationType\":\"$mode\",\"episodeString\":\"$ep_no\"}" --data-urlencode "query=$episode_embed_gql" -A "$agent" | tr '{}' '\n' | sed 's|\\u002F|\/|g;s|\\||g' | sed -nE 's|.*sourceUrl":"--([^"]*)".*sourceName":"([^"]*)".*|\2 :\1|p')
    # generate links into sequential files
    cache_dir="$(mktemp -d)"
    providers="1 2 3 4"
    for provider in $providers; do
        generate_link "$provider" >"$cache_dir"/"$provider" &
    done
    wait
    # select the link with matching quality
    links=$(cat "$cache_dir"/* | sort -g -r -s)
    rm -r "$cache_dir"
    select_quality "$quality"
    if printf "%s" "$ep_list" | grep -q "^$ep_no$"; then
        [ -z "$episode" ] && die "Episode is released, but no valid sources!"
    else
        [ -z "$episode" ] && die "Episode not released!"
    fi
}

# search the query and give results
search_anime() {
    #shellcheck disable=SC2016
    search_gql='query( $search: SearchInput $limit: Int $page: Int $translationType: VaildTranslationTypeEnumType $countryOrigin: VaildCountryOriginEnumType ) { shows( search: $search limit: $limit page: $page translationType: $translationType countryOrigin: $countryOrigin ) { edges { _id name availableEpisodes __typename } }}'

    curl -e "$allanime_refr" -s -G "${allanime_api}/api" --data-urlencode "variables={\"search\":{\"allowAdult\":false,\"allowUnknown\":false,\"query\":\"$1\"},\"limit\":40,\"page\":1,\"translationType\":\"$mode\",\"countryOrigin\":\"ALL\"}" --data-urlencode "query=$search_gql" -A "$agent" | sed 's|Show|\
| g' | sed -nE "s|.*_id\":\"([^\"]*)\",\"name\":\"(.+)\",.*${mode}\":([1-9][^,]*).*|\1	\2 (\3 episodes)|p" | sed 's/\\"//g'
}

time_until_next_ep() {
    animeschedule="https://animeschedule.net"
    query="$(printf "%s\n" "$*" | tr ' ' '+')"
    curl -s -G "$animeschedule/api/v3/anime" --data "q=${query}" | sed 's|"id"|\n|g' | sed -nE 's|.*,"route":"([^"]*)","premier.*|\1|p' | while read -r anime; do
        data=$(curl -s "$animeschedule/anime/$anime" | sed '1,/"anime-header-list-buttons-wrapper"/d' | sed -nE 's|.*countdown-time-raw" datetime="([^"]*)">.*|Next Raw Release: \1|p;s|.*countdown-time" datetime="([^"]*)">.*|Next Sub Release: \1|p;s|.*english-title">([^<]*)<.*|English Title: \1|p;s|.*main-title".*>([^<]*)<.*|Japanese Title: \1|p')
        status="Ongoing"
        color="33"
        printf "%s\n" "$data"
        ! (printf "%s\n" "$data" | grep -q "Next Raw Release:") && status="Finished" && color="32"
        printf "Status:  \033[1;%sm%s\033[0m\n---\n" "$color" "$status"
    done
    exit 0
}

# get the episodes list of the selected anime
episodes_list() {
    #shellcheck disable=SC2016
    episodes_list_gql='query ($showId: String!) { show( _id: $showId ) { _id availableEpisodesDetail }}'

    curl -e "$allanime_refr" -s -G "${allanime_api}/api" --data-urlencode "variables={\"showId\":\"$*\"}" --data-urlencode "query=$episodes_list_gql" -A "$agent" | sed -nE "s|.*$mode\":\[([0-9.\",]*)\].*|\1|p" | sed 's|,|\
|g; s|"||g' | sort -n -k 1
}

# PLAYING

process_hist_entry() {
    ep_list=$(episodes_list "$id")
    latest_ep=$(printf "%s\n" "$ep_list" | tail -n1)
    title=$(printf "%s\n" "$title" | sed "s|[0-9]\+ episodes|${latest_ep} episodes|")
    ep_no=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{n;p;}") 2>/dev/null
    [ -n "$ep_no" ] && printf "%s\t%s - episode %s\n" "$id" "$title" "$ep_no"
}

update_history() {
    if grep -q -- "$id" "$histfile"; then
        sed -E "s|^[^	]+	${id}	[^	]+$|${ep_no}	${id}	${title}|" "$histfile" >"${histfile}.new"
    else
        cp "$histfile" "${histfile}.new"
        printf "%s\t%s\t%s\n" "$ep_no" "$id" "$title" >>"${histfile}.new"
    fi
    mv "${histfile}.new" "$histfile"
}

download() {
    # download subtitle if it's set
    [ -n "$subtitle" ] && curl -s "$subtitle" -o "$download_dir/$2.vtt"
    case $1 in
        *m3u8*)
            if command -v "yt-dlp" >/dev/null; then
                yt-dlp --referer "$m3u8_refr" "$1" --no-skip-unavailable-fragments --fragment-retries infinite -N 16 -o "$download_dir/$2.mp4"
            else
                ffmpeg -extension_picky 0 -referer "$m3u8_refr" -loglevel error -stats -i "$1" -c copy "$download_dir/$2.mp4"
            fi
            # embed subs into downloads
            # [ -e "$download_dir/$2.vtt" ] && ffmpeg -i "$download_dir/$2.mp4" -i "$download_dir/$2.vtt" -c copy -c:s mov_text "$download_dir/$2.bak.mp4" && mv "$download_dir/$2.bak.mp4" "$download_dir/$2.mp4"
            ;;
        *)
            # shellcheck disable=SC2086
            aria2c --referer="$allanime_refr" --enable-rpc=false --check-certificate=false --continue $iSH_DownFix --summary-interval=0 -x 16 -s 16 "$1" --dir="$download_dir" -o "$2.mp4" --download-result=hide
            ;;
    esac
}

# Function to play a single episode
# This function handles the actual playback of an episode using the specified player.
# It is called by the main `play` function.
play_episode() {
    # --- Setup for Episode Playback ---
    # Store the current cursor position so we can return to it after printing
    [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && tput sc

    # --- Get the Episode Link ---
    # Ensure the episode link is fetched or available
    [ -z "$episode" ] && get_episode_url

    # --- Prepare Player Arguments ---
    # Handle subtitle and refresh flags based on player
    [ -n "$subs_flag" ] && [ "$player_function" != *mpv* ] && subs_flag="--sub-file=$subtitle"
    [ -n "$refr_flag" ] && [ "$player_function" != *mpv* ] && refr_flag="--framedrop=${refr_flag#--}"

    # --- Logging ---
    # Log the episode being played if enabled and not in debug/download mode
    [ "$log_episode" = 1 ] && [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && command -v logger >/dev/null && logger -t ani-cli "${allanime_title}${ep_no}"

    # --- Skip Intro (if enabled) ---
    # Get skip intro timecodes if the feature is enabled
    [ "$skip_intro" = 1 ] && skip_flag="$(ani-skip -q "$mal_id" -e "$ep_no")"

    # --- Debug Mode ---
    # If in debug mode, just print the links and exit
    [ "$player_function" = "debug" ] && {
        printf "All links:%sSelected link:" "$links"
        printf "%s" "$episode"
        return
    }

    # --- Player Execution ---
    # Use case statement to handle different player configurations
    # shellcheck disable=SC2086
    case "$player_function" in
        *mpv*)
            # --- mpv Player ---
            if [ "$no_detach" = 0 ]; then
                # Detached mode (runs in background)
                if [ "$use_external_menu" = 1 ]; then
                    # External menu is used, run mpv in background
                    nohup $player_function "$episode" --force-media-title="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag $skip_flag >/dev/null 2>&1 &
                else
                    # Standard detached mode
                    $player_function "$episode" --force-media-title="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag $skip_flag >/dev/null 2>&1 &
                fi
                # Wait for mpv process to start and get its PID
                PID=$!
                # Give mpv a moment to start
                sleep 1
                # Check if mpv process is still running
                if ps -p $PID >/dev/null 2>&1; then
                    # If running, wait for it to finish
                    wait $PID
                    mpv_exitcode=$?
                else
                    # If not running, get the exit code immediately
                    mpv_exitcode=$?
                fi
            else
                # Non-detached mode (runs in foreground)
                $player_function "$episode" --force-media-title="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag $skip_flag
                mpv_exitcode=$?
            fi
            ;;
        *vlc*)
            # --- VLC Player ---
            if [ "$no_detach" = 0 ]; then
                # Detached mode (background)
                if [ "$use_external_menu" = 1 ]; then
                    # External menu used, run VLC in background
                    nohup $player_function "$episode" --input-title-format="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag >/dev/null 2>&1 &
                else
                    # Standard detached mode
                    $player_function "$episode" --input-title-format="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag >/dev/null 2>&1 &
                fi
                # Wait for VLC to finish
                wait
            else
                # Non-detached mode (foreground)
                $player_function "$episode" --input-title-format="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag
            fi
            ;;
        syncplay*)
            # --- Syncplay ---
            # Run syncplay in background
            nohup $player_function "$episode" -- --force-media-title="${allanime_title}Episode ${ep_no}" $subs_flag $refr_flag >/dev/null 2>&1 &
            ;;
        download)
            # --- Download Mode ---
            # Call the player function to download the episode
            "$player_function" "$episode" "${allanime_title}Episode ${ep_no}" "$subtitle"
            ;;
        catt)
            # --- Cast to Device (catt) ---
            # Run catt in background
            nohup catt cast "$episode" -s "$subtitle" >/dev/null 2>&1 &
            ;;
        iSH)
            # --- iSH (iOS Shell) ---
            # Print a clickable link for VLC on iOS
            printf "\e]8;;vlc://%s\a~~~~~~~~~~~~~~~~~~~~~ Tap to open VLC ~~~~~~~~~~~~~~~~~~~~~\e]8;;\a" "$episode"
            sleep 5
            ;;
        *)
            # --- Default Player ---
            # Run the player in background
            nohup $player_function "$episode" >/dev/null 2>&1 &
            ;;
    esac

    # --- Store Replay Link ---
    # Save the episode link in case it's needed for replay
    replay="$episode"
    # Unset the episode variable
    unset episode

    # --- Post-Playback Actions ---
    # Update the local history file after playback finishes.
    update_history

    anilist_auto_track "$allanime_title" "$ep_no"

    # Wait for any background jobs to finish if external menu is used
    [ "$use_external_menu" = "1" ] && wait

    # If the script is set to exit after playing and it wasn't a range, exit with mpv's exit code
    [ "$exit_after_play" = 1 ] && [ -z "$range" ] && exit "$mpv_exitcode"
}

play() {
    start=$(printf "%s" "$ep_no" | grep -Eo '^(-1|[0-9]+(\.[0-9]+)?)')
    end=$(printf "%s" "$ep_no" | grep -Eo '(-1|[0-9]+(\.[0-9]+)?)$')
    [ "$start" = "-1" ] && ep_no=$(printf "%s" "$ep_list" | tail -n1) && unset start
    [ -z "$end" ] || [ "$end" = "$start" ] && unset start end
    [ "$end" = "-1" ] && end=$(printf "%s" "$ep_list" | tail -n1)
    line_count=$(printf "%s\n" "$ep_no" | wc -l | tr -d "[:space:]")
    if [ "$line_count" != 1 ] || [ -n "$start" ]; then
        [ -z "$start" ] && start=$(printf "%s\n" "$ep_no" | head -n1)
        [ -z "$end" ] && end=$(printf "%s\n" "$ep_no" | tail -n1)
        range=$(printf "%s\n" "$ep_list" | sed -nE "/^${start}\$/,/^${end}\$/p")
        [ -z "$range" ] && die "Invalid range!"
        for i in $range; do
            tput clear
            ep_no=$i
            printf "\33[2K\r\033[1;34mPlaying episode %s...\033[0m\n" "$ep_no"
            [ "$i" = "$end" ] && unset range
            play_episode
        done
    else
        play_episode
    fi
    # moves up to stored position and deletes to end
    [ "$player_function" != "debug" ] && [ "$player_function" != "download" ] && tput rc && tput ed
}

# MAIN

# setup
agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0"
allanime_refr="https://allmanga.to"
allanime_base="allanime.day"
allanime_api="https://api.${allanime_base}"
mode="${ANI_CLI_MODE:-sub}"
download_dir="${ANI_CLI_DOWNLOAD_DIR:-.}"
log_episode="${ANI_CLI_LOG:-1}"
quality="${ANI_CLI_QUALITY:-best}"
case "$(uname -a | cut -d " " -f 1,3-)" in
    *Darwin*) player_function="${ANI_CLI_PLAYER:-$(where_iina)}" ;;   # mac OS
    *ndroid*) player_function="${ANI_CLI_PLAYER:-android_mpv}" ;;     # Android OS (termux)
    *MINGW* | *WSL2*) player_function="${ANI_CLI_PLAYER:-mpv.exe}" ;; # Windows OS
    *ish*) player_function="${ANI_CLI_PLAYER:-iSH}" ;;                # iOS (iSH)
    *) player_function="${ANI_CLI_PLAYER:-$(where_mpv)}" ;;           # Linux OS
esac

no_detach="${ANI_CLI_NO_DETACH:-0}"
exit_after_play="${ANI_CLI_EXIT_AFTER_PLAY:-0}"
use_external_menu="${ANI_CLI_EXTERNAL_MENU:-0}"
external_menu_normal_window="${ANI_CLI_EXTERNAL_MENU_NORMAL_WINDOW:-0}"
skip_intro="${ANI_CLI_SKIP_INTRO:-0}"
# shellcheck disable=SC2154
skip_title="$ANI_CLI_SKIP_TITLE"
[ -t 0 ] || use_external_menu=1
hist_dir="${ANI_CLI_HIST_DIR:-${XDG_STATE_HOME:-$HOME/.local/state}/ani-cli}"
[ ! -d "$hist_dir" ] && mkdir -p "$hist_dir"
histfile="$hist_dir/ani-hsts"
[ ! -f "$histfile" ] && : >"$histfile"
search="${ANI_CLI_DEFAULT_SOURCE:-scrape}"

while [ $# -gt 0 ]; do
    case "$1" in
        -v | --vlc)
            case "$(uname -a | cut -d " " -f 1,3-)" in
                *ndroid*) player_function="android_vlc" ;;
                MINGW* | *WSL2*) player_function="vlc.exe" ;;
                *ish*) player_function="iSH" ;;
                *) player_function="vlc" ;;
            esac
            ;;
        -s | --syncplay)
            case "$(uname -s)" in
                Darwin*) player_function="/Applications/Syncplay.app/Contents/MacOS/syncplay" ;;
                MINGW* | *Msys)
                    export PATH="$PATH":"/c/Program Files (x86)/Syncplay/"
                    player_function="syncplay.exe"
                    ;;
                *) player_function="syncplay" ;;
            esac
            ;;
        -q | --quality)
            [ $# -lt 2 ] && die "missing argument!"
            quality="$2"
            shift
            ;;
        -S | --select-nth)
            [ $# -lt 2 ] && die "missing argument!"
            index="$2"
            shift
            ;;
        -c | --continue) search=history ;;
        -d | --download)
            [ "$player_function" = "iSH" ] && iSH_DownFix="--async-dns=false"
            player_function=download
            ;;
        -D | --delete)
            : >"$histfile"
            exit 0
            ;;
        -l | --logview)
            case "$(uname -s)" in
                Darwin*) log show --predicate 'process == "logger"' ;;
                Linux*) journalctl -t ani-cli ;;
                *) die "Logger not implemented for your platform" ;;
            esac
            exit 0
            ;;
        -V | --version) version_info ;;
        -h | --help) help_info ;;
        -e | --episode | -r | --range)
            [ $# -lt 2 ] && die "missing argument!"
            ep_no="$2"
            shift
            ;;
        --dub) mode="dub" ;;
        --no-detach) no_detach=1 ;;
        --exit-after-play) exit_after_play=1 && no_detach=1 ;;
        --rofi) use_external_menu=1 ;;
        --skip) skip_intro=1 ;;
        --skip-title)
            [ $# -lt 2 ] && die "missing argument!"
            skip_title="$2"
            shift
            ;;
        -N | --nextep-countdown) search=nextep ;;
        # --- AniList Commands ---
        anilist-setup)
            anilist_setup
            ;;
        anilist-auth)
            anilist_auth
            ;;
        anilist-search)
            shift
            if [ $# -lt 1 ]; then
                die "Usage: ani-cli anilist-search <search_term>"
            fi
            # Join remaining arguments for multi-word searches
            local search_query=""
            while [ $# -gt 0 ]; do
                if [ -z "$search_query" ]; then
                    search_query="$1"
                else
                    search_query="$search_query $1"
                fi
                shift
            done
            anilist_search "$search_query"
            ;;
        --A)
            search=anilist
            ;;
        anilist-update)
            shift
            if [ $# -lt 2 ]; then
                die "Usage: ani-cli anilist-update <media_id> <progress> [status]"
            fi
            local aid="$1"
            local prog="$2"
            local stat="$3" # Optional
            anilist_update_progress "$aid" "$prog" "$stat"
            ;;
        anilist-list)
            anilist_get_list
            ;;
        # --- End AniList Commands ---
        -U | --update) update_script ;;
        *) query="$(printf "%s" "$query $1" | sed "s|^ ||;s| |+|g")" ;;
    esac
    shift
done
[ "$use_external_menu" = "0" ] && multi_selection_flag="${ANI_CLI_MULTI_SELECTION:-"-m"}"
[ "$use_external_menu" = "1" ] && multi_selection_flag="${ANI_CLI_MULTI_SELECTION:-"-multi-select"}"
[ "$external_menu_normal_window" = "1" ] && external_menu_args="-normal-window"
printf "\33[2K\r\033[1;34mChecking dependencies...\033[0m\n"
dep_ch "curl" "sed" "grep" || true
[ "$skip_intro" = 1 ] && (dep_ch "ani-skip" || true)
dep_ch "fzf" || true
case "$player_function" in
    debug) ;;
    download) dep_ch "ffmpeg" "aria2c" ;;
    android*) printf "\33[2K\rChecking of players on Android is disabled\n" ;;
    *iSH*) printf "\33[2K\rChecking of players on iOS is disabled\n" ;;
    flatpak_mpv) true ;; # handled out of band in where_mpv
    *) dep_ch "$player_function" ;;
esac

# searching
case "$search" in
    history)
        anime_list=$(while read -r ep_no id title; do process_hist_entry & done <"$histfile")
        wait
        [ -z "$anime_list" ] && die "No unwatched series in history!"
        [ -z "${index##*[!0-9]*}" ] && id=$(printf "%s" "$anime_list" | nl -w 2 | sed 's/^[[:space:]]//' | nth "Select anime: " | cut -f1)
        [ -z "${index##*[!0-9]*}" ] || id=$(printf "%s" "$anime_list" | sed -n "${index}p" | cut -f1)
        [ -z "$id" ] && exit 1
        title=$(printf "%s" "$anime_list" | grep "$id" | cut -f2 | sed 's/ - episode.*//')
        ep_list=$(episodes_list "$id")
        ep_no=$(printf "%s" "$anime_list" | grep "$id" | cut -f2 | sed -nE 's/.*- episode (.+)$/\1/p')
        allanime_title="$(printf "%s" "$title" | cut -d'(' -f1 | tr -d '[:punct:]')"
        ;;
    anilist)
        # - Anilist Selection Mode -
        # Call the function to handle the logic
        select_from_anilist
        ;;


    *)
        if [ "$use_external_menu" = "0" ]; then
            while [ -z "$query" ]; do
                printf "\33[2K\r\033[1;36mSearch anime: \033[0m" && read -r query
            done
        else
            [ -z "$query" ] && query=$(printf "" | external_menu "" "Search anime: " "$external_menu_args")
            [ -z "$query" ] && exit 1
        fi
        # for checking new releases by specifying anime name
        [ "$search" = "nextep" ] && time_until_next_ep "$query"

        query=$(printf "%s" "$query" | sed "s| |+|g")
        anime_list=$(search_anime "$query")
        [ -z "$anime_list" ] && die "No results found!"
        [ "$index" -eq "$index" ] 2>/dev/null && result=$(printf "%s" "$anime_list" | sed -n "${index}p")
        [ -z "$index" ] && result=$(printf "%s" "$anime_list" | nl -w 2 | sed 's/^[[:space:]]//' | nth "Select anime: ")
        [ -z "$result" ] && exit 1
        title=$(printf "%s" "$result" | cut -f2)
        allanime_title="$(printf "%s" "$title" | cut -d'(' -f1 | tr -d '[:punct:]')"
        id=$(printf "%s" "$result" | cut -f1)
        ep_list=$(episodes_list "$id")
        [ -z "$ep_no" ] && ep_no=$(printf "%s" "$ep_list" | nth "Select episode: " "$multi_selection_flag")
        [ -z "$ep_no" ] && exit 1
        ;;
esac
[ "$skip_intro" = 1 ] && mal_id="$(ani-skip -q "${skip_title:-${title}}")"

# moves the cursor up one line and clears that line
tput cuu1 && tput el
# stores the position of cursor
tput sc

# playback & loop
play
[ "$player_function" = "download" ] || [ "$player_function" = "debug" ] && exit 0

while cmd=$(printf "next\nreplay\nprevious\nselect\nchange_quality\nquit" | nth "Playing episode $ep_no of $title... "); do
    case "$cmd" in
        next) ep_no=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{n;p;}") 2>/dev/null ;;
        replay) episode="$replay" ;;
        previous) ep_no=$(printf "%s" "$ep_list" | sed -n "/^${ep_no}$/{g;1!p;};h") 2>/dev/null ;;
        select) ep_no=$(printf "%s" "$ep_list" | nth "Select episode: " "$multi_selection_flag") ;;
        change_quality)
            new_quality="$(printf "%s" "$links" | launcher | cut -d\> -f1)"
            select_quality "$new_quality"
            ;;
        *) exit 0 ;;
    esac
    [ -z "$ep_no" ] && die "Out of range"
    play
done

# ani-cli
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Project repository: https://github.com/pystardust/ani-cli
